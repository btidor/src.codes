import * as vscode from 'vscode';
import axios from 'axios';

import { Config, constructUri, Package } from '../types/common';

type Symbols = { [tag: string]: vscode.SymbolInformation[]; };

const CTAGS_SPLIT = /\t|;"\t/;

export default class SymbolsClient {
    private config: Config;

    // A cache of the package-local symbols for each package as generated by the
    // ctags program. Lazy-loaded.
    private locals: { [pkgName: string]: Thenable<Symbols>; };

    // A list of all exported symbols across all pacakges, generated from the
    // Debian 'symbols' indexes.
    private globals: Thenable<Symbols>;

    constructor(config: Config) {
        this.config = config;
        this.locals = {};

        // Download globals index
        const url = vscode.Uri.joinPath(this.config.meta, this.config.distribution, "symbols.txt");
        this.globals = axios
            .get(url.toString(), { responseType: 'text' })
            .then(res => {
                const syms: Symbols = {};
                let pkgName = undefined;
                let symName = undefined;
                for (const line of res.data.split("\n")) {
                    if (line.startsWith("### ")) {
                        pkgName = line.split(" ")[1];
                    } else if (line.startsWith(" - ") && pkgName && symName) {
                        const parts = line.substring(3).split(CTAGS_SPLIT);
                        const info = this.parseCtagsLine(symName, pkgName, parts, true);
                        if (info) {
                            syms[info.name] ||= [];
                            syms[info.name].push(info);
                        }
                    } else if (line.startsWith(" ")) {
                        symName = line.split(/[ @]/)[1];
                    }
                }
                return syms;
            })
            .catch(err => {
                throw vscode.FileSystemError.Unavailable(err);
            });
    }

    listPackageSymbols(pkg: Package): Thenable<Symbols> {
        if (!(pkg.name in this.locals)) {
            const filename = pkg.name + "_" + pkg.version + ":" + pkg.epoch + ".tags";
            const url = vscode.Uri.joinPath(this.config.ls, this.config.distribution, pkg.name, filename);
            return axios
                .get(url.toString(), { responseType: 'text' })
                .then(res => {
                    const syms: Symbols = {};
                    for (const line of res.data.trim().split("\n")) {
                        const parts = line.split(CTAGS_SPLIT);
                        const info = this.parseCtagsLine(parts[0], pkg.name, parts.slice(1), false);
                        if (info) {
                            syms[info.name] ||= [];
                            syms[info.name].push(info);
                        }
                    }
                    return syms;
                })
                .catch(err => {
                    throw vscode.FileSystemError.Unavailable(err);
                });
        }
        return this.locals[pkg.name];
    }

    listGlobalSymbols(): Thenable<Symbols> {
        return this.globals;
    }

    private parseCtagsLine(name: string, pkgName: string, parts: string[], globalOnly: boolean): vscode.SymbolInformation | undefined {
        if (name.startsWith("(c++)\"")) {
            name = name.slice(6);
        }
        if (parts.indexOf("file:") >= 0 && globalOnly) {
            return undefined;
        }
        const uri = constructUri(this.config, pkgName, parts[0]);
        const range = new vscode.Position(Number(parts[1]) - 1, 0);
        return new vscode.SymbolInformation(
            name,
            this.parseTagKind(parts[2]) || vscode.SymbolKind.Null,
            "",
            new vscode.Location(uri, range),
        );
    }

    private parseTagKind(abbr: string): vscode.SymbolKind | undefined {
        switch (abbr) {
            case 'c':
                return vscode.SymbolKind.Class;
            case 'e':
                return vscode.SymbolKind.EnumMember;
            case 'f':
                return vscode.SymbolKind.Function;
            case 'F':
                return vscode.SymbolKind.File;
            case 'g':
                return vscode.SymbolKind.Enum;
            case 'm':
                return vscode.SymbolKind.Property;
            case 'p':
                return vscode.SymbolKind.Interface;
            case 's':
                return vscode.SymbolKind.Struct;
            case 'u':
                return vscode.SymbolKind.Enum;
            case 'v':
                return vscode.SymbolKind.Variable;
        }
        return undefined;
    }
}
